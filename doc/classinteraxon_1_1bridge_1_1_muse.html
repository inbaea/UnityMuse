<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LibMuse Windows 7.1.1: interaxon::bridge::Muse Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra_stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">LibMuse Windows 7.1.1
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classinteraxon_1_1bridge_1_1_muse.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classinteraxon_1_1bridge_1_1_muse-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">interaxon::bridge::Muse Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="bridge__muse_8h_source.html">bridge_muse.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae17a7c5caf76c8042abc05c132e4ed16"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinteraxon_1_1bridge_1_1_muse.html#ae17a7c5caf76c8042abc05c132e4ed16">~Muse</a> ()</td></tr>
<tr class="separator:ae17a7c5caf76c8042abc05c132e4ed16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2af408873d20bac71b233977a9932e72"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinteraxon_1_1bridge_1_1_muse.html#a2af408873d20bac71b233977a9932e72">connect</a> ()=0</td></tr>
<tr class="separator:a2af408873d20bac71b233977a9932e72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35afdc6fcaadd6f7577f005d769913f2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinteraxon_1_1bridge_1_1_muse.html#a35afdc6fcaadd6f7577f005d769913f2">disconnect</a> ()=0</td></tr>
<tr class="separator:a35afdc6fcaadd6f7577f005d769913f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c09309e9cc7ca88de6c7b51575e87dc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinteraxon_1_1bridge_1_1_muse.html#a8c09309e9cc7ca88de6c7b51575e87dc">execute</a> ()=0</td></tr>
<tr class="separator:a8c09309e9cc7ca88de6c7b51575e87dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdbab38fda3f2b2dd11b9c4adfe1ab52"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinteraxon_1_1bridge_1_1_muse.html#acdbab38fda3f2b2dd11b9c4adfe1ab52">run_asynchronously</a> ()=0</td></tr>
<tr class="separator:acdbab38fda3f2b2dd11b9c4adfe1ab52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70b92ff1451b45396be89f608f7dd41d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceinteraxon_1_1bridge.html#a9472fb1afae6a21e5e90e15f63ebbdb2">ConnectionState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinteraxon_1_1bridge_1_1_muse.html#a70b92ff1451b45396be89f608f7dd41d">get_connection_state</a> ()=0</td></tr>
<tr class="separator:a70b92ff1451b45396be89f608f7dd41d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa93893c9795a4b4b3e40b8ccf980336a"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinteraxon_1_1bridge_1_1_muse.html#aa93893c9795a4b4b3e40b8ccf980336a">get_mac_address</a> ()=0</td></tr>
<tr class="separator:aa93893c9795a4b4b3e40b8ccf980336a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98d88cf58c1032cdadb21378b5a770ef"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinteraxon_1_1bridge_1_1_muse.html#a98d88cf58c1032cdadb21378b5a770ef">get_name</a> ()=0</td></tr>
<tr class="separator:a98d88cf58c1032cdadb21378b5a770ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d1795f36db2d4d47b595847f7619c54"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinteraxon_1_1bridge_1_1_muse.html#a0d1795f36db2d4d47b595847f7619c54">get_rssi</a> ()=0</td></tr>
<tr class="separator:a0d1795f36db2d4d47b595847f7619c54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a25c962190a19d65c61af95f263cd0d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceinteraxon_1_1bridge.html#a7d8651cfe049653aafbd7b392c966780">MuseModel</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinteraxon_1_1bridge_1_1_muse.html#a9a25c962190a19d65c61af95f263cd0d">get_model</a> ()=0</td></tr>
<tr class="separator:a9a25c962190a19d65c61af95f263cd0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76df704cb123f07a8c6ff7e2f23869ed"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinteraxon_1_1bridge_1_1_muse.html#a76df704cb123f07a8c6ff7e2f23869ed">get_last_discovered_time</a> ()=0</td></tr>
<tr class="separator:a76df704cb123f07a8c6ff7e2f23869ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c14c72dc1587452924da325f9e6b083"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinteraxon_1_1bridge_1_1_muse.html#a7c14c72dc1587452924da325f9e6b083">set_num_connect_tries</a> (int32_t num_tries)=0</td></tr>
<tr class="separator:a7c14c72dc1587452924da325f9e6b083"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa713bdcdc3396804dcaedb6605c95a8b"><td class="memItemLeft" align="right" valign="top">virtual std::shared_ptr&lt; <a class="el" href="classinteraxon_1_1bridge_1_1_muse_configuration.html">MuseConfiguration</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinteraxon_1_1bridge_1_1_muse.html#aa713bdcdc3396804dcaedb6605c95a8b">get_muse_configuration</a> ()=0</td></tr>
<tr class="separator:aa713bdcdc3396804dcaedb6605c95a8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab29b721e6bb4cb1cb43b603dceb0047c"><td class="memItemLeft" align="right" valign="top">virtual std::shared_ptr&lt; <a class="el" href="classinteraxon_1_1bridge_1_1_muse_version.html">MuseVersion</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinteraxon_1_1bridge_1_1_muse.html#ab29b721e6bb4cb1cb43b603dceb0047c">get_muse_version</a> ()=0</td></tr>
<tr class="separator:ab29b721e6bb4cb1cb43b603dceb0047c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2afbe3329fe350b9297eefa7eb00810"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinteraxon_1_1bridge_1_1_muse.html#af2afbe3329fe350b9297eefa7eb00810">register_connection_listener</a> (const std::shared_ptr&lt; <a class="el" href="classinteraxon_1_1bridge_1_1_muse_connection_listener.html">MuseConnectionListener</a> &gt; &amp;listener)=0</td></tr>
<tr class="separator:af2afbe3329fe350b9297eefa7eb00810"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46adba7aa089b8a4afd4299d61c10789"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinteraxon_1_1bridge_1_1_muse.html#a46adba7aa089b8a4afd4299d61c10789">unregister_connection_listener</a> (const std::shared_ptr&lt; <a class="el" href="classinteraxon_1_1bridge_1_1_muse_connection_listener.html">MuseConnectionListener</a> &gt; &amp;listener)=0</td></tr>
<tr class="separator:a46adba7aa089b8a4afd4299d61c10789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0946da844c177b47c650e1053d871dc9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinteraxon_1_1bridge_1_1_muse.html#a0946da844c177b47c650e1053d871dc9">register_data_listener</a> (const std::shared_ptr&lt; <a class="el" href="classinteraxon_1_1bridge_1_1_muse_data_listener.html">MuseDataListener</a> &gt; &amp;listener, <a class="el" href="namespaceinteraxon_1_1bridge.html#a7563f828d33f62e2b2f161b41a0d6846">MuseDataPacketType</a> type)=0</td></tr>
<tr class="separator:a0946da844c177b47c650e1053d871dc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8514eba1643c357304bbd20ddbd54bcf"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinteraxon_1_1bridge_1_1_muse.html#a8514eba1643c357304bbd20ddbd54bcf">unregister_data_listener</a> (const std::shared_ptr&lt; <a class="el" href="classinteraxon_1_1bridge_1_1_muse_data_listener.html">MuseDataListener</a> &gt; &amp;listener, <a class="el" href="namespaceinteraxon_1_1bridge.html#a7563f828d33f62e2b2f161b41a0d6846">MuseDataPacketType</a> type)=0</td></tr>
<tr class="separator:a8514eba1643c357304bbd20ddbd54bcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a421c0ab37225a6d02f44f2d876432219"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinteraxon_1_1bridge_1_1_muse.html#a421c0ab37225a6d02f44f2d876432219">register_error_listener</a> (const std::shared_ptr&lt; <a class="el" href="classinteraxon_1_1bridge_1_1_muse_error_listener.html">MuseErrorListener</a> &gt; &amp;listener)=0</td></tr>
<tr class="separator:a421c0ab37225a6d02f44f2d876432219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d5fa838dbbb00161675d251c8254718"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinteraxon_1_1bridge_1_1_muse.html#a7d5fa838dbbb00161675d251c8254718">unregister_error_listener</a> (const std::shared_ptr&lt; <a class="el" href="classinteraxon_1_1bridge_1_1_muse_error_listener.html">MuseErrorListener</a> &gt; &amp;listener)=0</td></tr>
<tr class="separator:a7d5fa838dbbb00161675d251c8254718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a903837955a3aa1fd0b3d27d52754080e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinteraxon_1_1bridge_1_1_muse.html#a903837955a3aa1fd0b3d27d52754080e">unregister_all_listeners</a> ()=0</td></tr>
<tr class="separator:a903837955a3aa1fd0b3d27d52754080e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abba7b627c86e7ca0b2d4548f37410ba4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinteraxon_1_1bridge_1_1_muse.html#abba7b627c86e7ca0b2d4548f37410ba4">set_preset</a> (<a class="el" href="namespaceinteraxon_1_1bridge.html#a1a322b306f3f093aa4e1a504e37ac6fe">MusePreset</a> preset)=0</td></tr>
<tr class="separator:abba7b627c86e7ca0b2d4548f37410ba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acce836c82822e6ad245756a86d656fd0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinteraxon_1_1bridge_1_1_muse.html#acce836c82822e6ad245756a86d656fd0">enable_led_indicator</a> (bool enable)=0</td></tr>
<tr class="separator:acce836c82822e6ad245756a86d656fd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf0d5fd0cadad530615f7b391741b4b4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinteraxon_1_1bridge_1_1_muse.html#adf0d5fd0cadad530615f7b391741b4b4">enable_data_transmission</a> (bool enable)=0</td></tr>
<tr class="separator:adf0d5fd0cadad530615f7b391741b4b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1936b8edbac90c239cd1b4412802875c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinteraxon_1_1bridge_1_1_muse.html#a1936b8edbac90c239cd1b4412802875c">set_notch_frequency</a> (<a class="el" href="namespaceinteraxon_1_1bridge.html#a58395a61de0e5043388e9b077c1da576">NotchFrequency</a> new_frequency)=0</td></tr>
<tr class="separator:a1936b8edbac90c239cd1b4412802875c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7340d70dfc7b68521d8a6fdafb32c64c"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinteraxon_1_1bridge_1_1_muse.html#a7340d70dfc7b68521d8a6fdafb32c64c">is_low_energy</a> ()=0</td></tr>
<tr class="separator:a7340d70dfc7b68521d8a6fdafb32c64c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a131038e662cb8d808a6d9d822ddc10af"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinteraxon_1_1bridge_1_1_muse.html#a131038e662cb8d808a6d9d822ddc10af">is_paired</a> ()=0</td></tr>
<tr class="separator:a131038e662cb8d808a6d9d822ddc10af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d399054be79e248544015ac35ad74f8"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinteraxon_1_1bridge_1_1_muse.html#a3d399054be79e248544015ac35ad74f8">is_connectable</a> ()=0</td></tr>
<tr class="separator:a3d399054be79e248544015ac35ad74f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a207c84a2673ca83025854eead6857937"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinteraxon_1_1bridge_1_1_muse.html#a207c84a2673ca83025854eead6857937">set_license_data</a> (const std::vector&lt; uint8_t &gt; &amp;data)=0</td></tr>
<tr class="separator:a207c84a2673ca83025854eead6857937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ac0f605d8c71c8e9896e45e870fe09f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinteraxon_1_1bridge_1_1_muse.html#a7ac0f605d8c71c8e9896e45e870fe09f">enable_exception</a> (bool enable)=0</td></tr>
<tr class="separator:a7ac0f605d8c71c8e9896e45e870fe09f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Provides the client interface to a specific Muse Headband.</p>
<p>This class maps to a single Muse Headband, providing an API for receiving connection events and data packets, as well as the ability to inspect various properties of the headband it corresponds to. Users can initiate and halt a connection to the device, enable data transmission, find out the human-readable name of the headband, etc.</p>
<p>This class should never be constructed directly by a user; rather, references to it can be retrieved from <a class="el" href="classinteraxon_1_1bridge_1_1_muse_manager.html">MuseManager</a>.</p>
<p>There are two main ways of interacting with a Muse:</p><ol type="1">
<li>calling  <a class="el" href="classinteraxon_1_1bridge_1_1_muse.html#acdbab38fda3f2b2dd11b9c4adfe1ab52">run_asynchronously()</a>  <br  />
</li>
<li>calling  <a class="el" href="classinteraxon_1_1bridge_1_1_muse.html#a2af408873d20bac71b233977a9932e72">connect()</a>  on your own and then repeatedly calling  <a class="el" href="classinteraxon_1_1bridge_1_1_muse.html#a8c09309e9cc7ca88de6c7b51575e87dc">execute()</a> </li>
</ol>
<p>If you call  <a class="el" href="classinteraxon_1_1bridge_1_1_muse.html#acdbab38fda3f2b2dd11b9c4adfe1ab52">run_asynchronously()</a>  , you do not need to call  <a class="el" href="classinteraxon_1_1bridge_1_1_muse.html#a2af408873d20bac71b233977a9932e72">connect()</a>  or  <a class="el" href="classinteraxon_1_1bridge_1_1_muse.html#a8c09309e9cc7ca88de6c7b51575e87dc">execute()</a>  on your own. Everything is taken care of by LibMuse for the duration of the connection (i.e. until you receive a disconnected event).</p>
<p>If you call  <a class="el" href="classinteraxon_1_1bridge_1_1_muse.html#a2af408873d20bac71b233977a9932e72">connect()</a>  on your own, you are responsible for calling  <a class="el" href="classinteraxon_1_1bridge_1_1_muse.html#a8c09309e9cc7ca88de6c7b51575e87dc">execute()</a>  on your own as well. Execute performs small, non-blocking steps of work such as initiating a connection, streaming data or disconnecting. If  <a class="el" href="classinteraxon_1_1bridge_1_1_muse.html#a8c09309e9cc7ca88de6c7b51575e87dc">execute()</a>  is not called, no work is performed. The Muse will not transition its connection state and you will not receive any data. If you are using this method of interacting with a Muse you need to continue calling  <a class="el" href="classinteraxon_1_1bridge_1_1_muse.html#a8c09309e9cc7ca88de6c7b51575e87dc">execute()</a>  until you receive a DISCONNECTED event through a registered connection listener. It may take multiple execute calls to reach the DISCONNECTED after issuing the disconnect request. Failure to wait for the DISCONNECTED event can result in unanticipated consequences. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae17a7c5caf76c8042abc05c132e4ed16" name="ae17a7c5caf76c8042abc05c132e4ed16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae17a7c5caf76c8042abc05c132e4ed16">&#9670;&#160;</a></span>~Muse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual interaxon::bridge::Muse::~Muse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a2af408873d20bac71b233977a9932e72" name="a2af408873d20bac71b233977a9932e72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2af408873d20bac71b233977a9932e72">&#9670;&#160;</a></span>connect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void interaxon::bridge::Muse::connect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initiate a connection to a Muse headband.</p>
<p>This call is non-blocking and returns immediately. Since this returns before the connection is established, you should instead use a connection listener to implement any logic, such as updating a UI element, on successful connection. When the connection is successful you will receive a CONNECTED event. If the connection is unsuccessful you will receive a DISCONNECTED event.</p>
<p><b>Threading:</b> method is thread-safe. </p>

</div>
</div>
<a id="a35afdc6fcaadd6f7577f005d769913f2" name="a35afdc6fcaadd6f7577f005d769913f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35afdc6fcaadd6f7577f005d769913f2">&#9670;&#160;</a></span>disconnect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void interaxon::bridge::Muse::disconnect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Disconnects your mobile device from Muse Headband.</p>
<p>If you are calling  <a class="el" href="classinteraxon_1_1bridge_1_1_muse.html#a8c09309e9cc7ca88de6c7b51575e87dc">execute()</a>  on your own, remember to continue calling  <a class="el" href="classinteraxon_1_1bridge_1_1_muse.html#a8c09309e9cc7ca88de6c7b51575e87dc">execute()</a>  until you receive the DISCONNECTED event.</p>
<p><b>Threading:</b> method is thread-safe. <br  />
</p>
<p>If you don't want to receive disconnection event, unregister listeners manually first. </p>

</div>
</div>
<a id="adf0d5fd0cadad530615f7b391741b4b4" name="adf0d5fd0cadad530615f7b391741b4b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf0d5fd0cadad530615f7b391741b4b4">&#9670;&#160;</a></span>enable_data_transmission()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void interaxon::bridge::Muse::enable_data_transmission </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Starts/stops data transmission (but keep-alive packets will be still sent). If you're using low-level interface (connect + execute), you should still call  <a class="el" href="classinteraxon_1_1bridge_1_1_muse.html#a8c09309e9cc7ca88de6c7b51575e87dc">execute()</a>  to continue sending keep-alive messages. If you're using  <a class="el" href="classinteraxon_1_1bridge_1_1_muse.html#acdbab38fda3f2b2dd11b9c4adfe1ab52">run_asynchronously()</a>  , then it will take care about sending keep-alive packets. <br  />
 <b>Threading:</b> method is thread-safe. You can call it in the middle of an execute operation. If method is called before connection is established, the right setting will be passed to device during connection routine. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td><code>true</code> to start streaming data. <code>false</code> to pause the data stream. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7ac0f605d8c71c8e9896e45e870fe09f" name="a7ac0f605d8c71c8e9896e45e870fe09f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ac0f605d8c71c8e9896e45e870fe09f">&#9670;&#160;</a></span>enable_exception()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void interaxon::bridge::Muse::enable_exception </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Enable/disable libmuse to rethrow any exceptions caught in your app code from the various listeners. For example, if there is a bug in your data listener code that results in an exception. Libmuse will catch that and it can rethrow that to cause your app to crash if enabled. Or if disabled it will swallow that exception and prevent the app from crashing. It is useful to enable this in development to help track down any bugs in your code more easily. It is best to disable this in production code to prevent your app from crashing. If this method is not called, the default is disabled. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td><code>true</code> to enable exception to be thrown. <code>false</code> to disable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acce836c82822e6ad245756a86d656fd0" name="acce836c82822e6ad245756a86d656fd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acce836c82822e6ad245756a86d656fd0">&#9670;&#160;</a></span>enable_led_indicator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void interaxon::bridge::Muse::enable_led_indicator </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Toggles the LED indicator state on Muse headbands supporting sleep. </p><dl class="section warning"><dt>Warning</dt><dd>The headband must be in the CONNECTED state before calling this method. <b> Threading: </b> method is thread-safe. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td><code>true</code> to turn indicator LEDs on. <code>false</code> to turn them off. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8c09309e9cc7ca88de6c7b51575e87dc" name="a8c09309e9cc7ca88de6c7b51575e87dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c09309e9cc7ca88de6c7b51575e87dc">&#9670;&#160;</a></span>execute()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void interaxon::bridge::Muse::execute </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Runs a single, non-blocking step of processing.</p>
<p>Reads data from Bluetooth if there is any; updates the connection state; sends packets to listeners; etc. This should be called relatively frequently: max 250ms, ideally 20ms.</p>
<p>If you are listening for computed values (e.g. band powers) rather than just raw EEG samples, then be aware that this method may trigger some amount of processing in the foreground before it returns. If this has undesirable effects on app performance, then you may want to move it to a dedicated thread.</p>
<p>Also be aware that all packets will be received on the same thread as  <a class="el" href="classinteraxon_1_1bridge_1_1_muse.html#a8c09309e9cc7ca88de6c7b51575e87dc">execute()</a>  is run.</p>
<p><b>Threading:</b> This method is NOT thread safe. You must synchronize the <a class="el" href="classinteraxon_1_1bridge_1_1_muse.html">Muse</a> object on your own if you wish to call it concurrently from more than one thread. </p>

</div>
</div>
<a id="a70b92ff1451b45396be89f608f7dd41d" name="a70b92ff1451b45396be89f608f7dd41d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70b92ff1451b45396be89f608f7dd41d">&#9670;&#160;</a></span>get_connection_state()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceinteraxon_1_1bridge.html#a9472fb1afae6a21e5e90e15f63ebbdb2">ConnectionState</a> interaxon::bridge::Muse::get_connection_state </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns current connection state. <br  />
<br  />
 <b>Threading:</b> method is thread-safe. </p><dl class="section return"><dt>Returns</dt><dd>The current connection state. </dd></dl>

</div>
</div>
<a id="a76df704cb123f07a8c6ff7e2f23869ed" name="a76df704cb123f07a8c6ff7e2f23869ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76df704cb123f07a8c6ff7e2f23869ed">&#9670;&#160;</a></span>get_last_discovered_time()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double interaxon::bridge::Muse::get_last_discovered_time </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the time at which this device was most recently discovered.</p>
<p><a class="el" href="classinteraxon_1_1bridge_1_1_muse.html">Muse</a> devices broadcast service information every few seconds, and this is the last time LibMuse has heard this broadcast info.</p>
<p>Only implemented on low-energy Muses. Returns NaN if called on non-low-energy Muses.</p>
<p>The value is in microseconds since some common start time (e.g. epoch, device start time, or app start time) that is guaranteed not to change within a running app process. The value may be used e.g. to determine which of two devices was discovered more recently than the other. It should not be used as an absolute time, nor should the common start time be assumed to be the same between any two running app instances.</p>
<dl class="section return"><dt>Returns</dt><dd>The time at which this device was most recently discovered. </dd></dl>

</div>
</div>
<a id="aa93893c9795a4b4b3e40b8ccf980336a" name="aa93893c9795a4b4b3e40b8ccf980336a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa93893c9795a4b4b3e40b8ccf980336a">&#9670;&#160;</a></span>get_mac_address()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string interaxon::bridge::Muse::get_mac_address </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns Bluetooth MAC address of the Muse Headband. <br  />
<br  />
 <b>Threading:</b> method is thread-safe. </p><dl class="section return"><dt>Returns</dt><dd>The MAC address of the Muse Headband. </dd></dl>

</div>
</div>
<a id="a9a25c962190a19d65c61af95f263cd0d" name="a9a25c962190a19d65c61af95f263cd0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a25c962190a19d65c61af95f263cd0d">&#9670;&#160;</a></span>get_model()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceinteraxon_1_1bridge.html#a7d8651cfe049653aafbd7b392c966780">MuseModel</a> interaxon::bridge::Muse::get_model </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the model of the Muse Headband. Eg. MU-02, GL-01, etc...</p>
<p>This should return a value for every <a class="el" href="classinteraxon_1_1bridge_1_1_muse.html">Muse</a> currently available.</p>
<p><b>Threading:</b> method is thread-safe. </p><dl class="section return"><dt>Returns</dt><dd>The model of the Muse Headband. </dd></dl>

</div>
</div>
<a id="aa713bdcdc3396804dcaedb6605c95a8b" name="aa713bdcdc3396804dcaedb6605c95a8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa713bdcdc3396804dcaedb6605c95a8b">&#9670;&#160;</a></span>get_muse_configuration()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::shared_ptr&lt; <a class="el" href="classinteraxon_1_1bridge_1_1_muse_configuration.html">MuseConfiguration</a> &gt; interaxon::bridge::Muse::get_muse_configuration </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns struct which contains all information about <a class="el" href="classinteraxon_1_1bridge_1_1_muse.html">Muse</a> configuration. <br  />
</p>
<p><b>Threading:</b> method is thread-safe. </p><dl class="section warning"><dt>Warning</dt><dd>The Muse Configuration object is only populated during connection routine or after headband settings (like preset or notch frequency) are changed. If this is called before the Muse is connected, the configuration will be <code>null</code>. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The configuration information of this Muse or <code>null</code> if the configuration is unknown. </dd></dl>

</div>
</div>
<a id="ab29b721e6bb4cb1cb43b603dceb0047c" name="ab29b721e6bb4cb1cb43b603dceb0047c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab29b721e6bb4cb1cb43b603dceb0047c">&#9670;&#160;</a></span>get_muse_version()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::shared_ptr&lt; <a class="el" href="classinteraxon_1_1bridge_1_1_muse_version.html">MuseVersion</a> &gt; interaxon::bridge::Muse::get_muse_version </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns all information about the version of the Muse. <br  />
</p>
<p><b>Threading:</b> method is thread-safe. </p><dl class="section warning"><dt>Warning</dt><dd>The Muse Version is populated during connection routine only. If this is called before the Muse is connected, the version will be <code>null</code>. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The version of this Muse or <code>null</code> if the version is unknown. </dd></dl>

</div>
</div>
<a id="a98d88cf58c1032cdadb21378b5a770ef" name="a98d88cf58c1032cdadb21378b5a770ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98d88cf58c1032cdadb21378b5a770ef">&#9670;&#160;</a></span>get_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string interaxon::bridge::Muse::get_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns Bluetooth name of the Muse Headband. <br  />
<br  />
 <b>Threading:</b> method is thread-safe. </p><dl class="section return"><dt>Returns</dt><dd>The name of the Muse Headband. </dd></dl>

</div>
</div>
<a id="a0d1795f36db2d4d47b595847f7619c54" name="a0d1795f36db2d4d47b595847f7619c54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d1795f36db2d4d47b595847f7619c54">&#9670;&#160;</a></span>get_rssi()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double interaxon::bridge::Muse::get_rssi </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the RSSI of this device.</p>
<p>Only implemented on low-energy Muses. Returns NaN if called on non-low-energy Muses.</p>
<p><b>Threading:</b> method is thread-safe. </p><dl class="section return"><dt>Returns</dt><dd>The RSSI of a low-energy Muse or NaN if the Muse is not low-energy. </dd></dl>

</div>
</div>
<a id="a3d399054be79e248544015ac35ad74f8" name="a3d399054be79e248544015ac35ad74f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d399054be79e248544015ac35ad74f8">&#9670;&#160;</a></span>is_connectable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool interaxon::bridge::Muse::is_connectable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if the <a class="el" href="classinteraxon_1_1bridge_1_1_muse.html">Muse</a> is connectable, false otherwise. This will always return true for Muse 2014 (  <a class="el" href="namespaceinteraxon_1_1bridge.html#a7d8651cfe049653aafbd7b392c966780a5cdccd438a6868468a0ade7172169f3a">MU_01</a>  ). For Muse 2016 (  <a class="el" href="namespaceinteraxon_1_1bridge.html#a7d8651cfe049653aafbd7b392c966780aa54d9cf7ce3423eab0cee654bbcb0874">MU_02</a>  ) or later headbands this will return true on Android and iOS. For Muse 2016 (  <a class="el" href="namespaceinteraxon_1_1bridge.html#a7d8651cfe049653aafbd7b392c966780aa54d9cf7ce3423eab0cee654bbcb0874">MU_02</a>  ) or later headbands on Windows, this will return true if the headband is advertising it is connectable, false if it is not.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the <a class="el" href="classinteraxon_1_1bridge_1_1_muse.html">Muse</a> is connectable, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a7340d70dfc7b68521d8a6fdafb32c64c" name="a7340d70dfc7b68521d8a6fdafb32c64c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7340d70dfc7b68521d8a6fdafb32c64c">&#9670;&#160;</a></span>is_low_energy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool interaxon::bridge::Muse::is_low_energy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>True if this device supports Bluetooth Low-Energy. </p><dl class="section return"><dt>Returns</dt><dd><code>true</code> if this Muse supports Bluetooth Low-Energy. <code>false</code> if it does not. </dd></dl>

</div>
</div>
<a id="a131038e662cb8d808a6d9d822ddc10af" name="a131038e662cb8d808a6d9d822ddc10af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a131038e662cb8d808a6d9d822ddc10af">&#9670;&#160;</a></span>is_paired()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool interaxon::bridge::Muse::is_paired </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if the <a class="el" href="classinteraxon_1_1bridge_1_1_muse.html">Muse</a> is paired with the OS, false otherwise. This will always return true for Muse 2014 (  <a class="el" href="namespaceinteraxon_1_1bridge.html#a7d8651cfe049653aafbd7b392c966780a5cdccd438a6868468a0ade7172169f3a">MU_01</a>  ). For Muse 2016 (  <a class="el" href="namespaceinteraxon_1_1bridge.html#a7d8651cfe049653aafbd7b392c966780aa54d9cf7ce3423eab0cee654bbcb0874">MU_02</a>  ) or later headbands this will return false on Android and iOS. For Muse 2016 (  <a class="el" href="namespaceinteraxon_1_1bridge.html#a7d8651cfe049653aafbd7b392c966780aa54d9cf7ce3423eab0cee654bbcb0874">MU_02</a>  ) or later headbands on Windows, this will return true if the headband is paired with the OS and false if it is not.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the <a class="el" href="classinteraxon_1_1bridge_1_1_muse.html">Muse</a> is paired with the OS, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="af2afbe3329fe350b9297eefa7eb00810" name="af2afbe3329fe350b9297eefa7eb00810"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2afbe3329fe350b9297eefa7eb00810">&#9670;&#160;</a></span>register_connection_listener()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void interaxon::bridge::Muse::register_connection_listener </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classinteraxon_1_1bridge_1_1_muse_connection_listener.html">MuseConnectionListener</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>listener</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Registers a connection listener. The same listener cannot be registered twice. If the listener was already registered, then this method does nothing. <br  />
<br  />
 <b> Threading: </b> method is thread-safe. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">listener</td><td>The listener to register. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0946da844c177b47c650e1053d871dc9" name="a0946da844c177b47c650e1053d871dc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0946da844c177b47c650e1053d871dc9">&#9670;&#160;</a></span>register_data_listener()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void interaxon::bridge::Muse::register_data_listener </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classinteraxon_1_1bridge_1_1_muse_data_listener.html">MuseDataListener</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>listener</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceinteraxon_1_1bridge.html#a7563f828d33f62e2b2f161b41a0d6846">MuseDataPacketType</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Registers a data listener. You can register the same listener to listen for different packet types - just call this method again. It's your responsibility to make sure that the listener handles all packet types correctly.</p>
<p>If this listener was already registered for this specific type then this method does nothing.</p>
<p><b> Threading: </b> method is thread-safe. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">listener</td><td>The listener to register. </td></tr>
    <tr><td class="paramname">type</td><td>The type of data packet the listener will receive. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a421c0ab37225a6d02f44f2d876432219" name="a421c0ab37225a6d02f44f2d876432219"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a421c0ab37225a6d02f44f2d876432219">&#9670;&#160;</a></span>register_error_listener()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void interaxon::bridge::Muse::register_error_listener </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classinteraxon_1_1bridge_1_1_muse_error_listener.html">MuseErrorListener</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>listener</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Registers an error listener.</p>
<p><b>Threading:</b> method is thread-safe. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">listener</td><td>The listener to register. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acdbab38fda3f2b2dd11b9c4adfe1ab52" name="acdbab38fda3f2b2dd11b9c4adfe1ab52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdbab38fda3f2b2dd11b9c4adfe1ab52">&#9670;&#160;</a></span>run_asynchronously()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void interaxon::bridge::Muse::run_asynchronously </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Connect to a headband out of the main logic flow.</p>
<p>This method handles all the connection logic for a single connection to a headband (i.e. starting with issuing a "connecting" event and ending with issuing a "disconnected" event). It may run in a separate thread or an event loop on the main thread; the details are platform-specific.</p>
<p>If this method is used, then all packets are delivered on the main thread.  Windows is an exception. On Windows all packets are delivered on a dedicated thread other than the main thread. </p>
<p>The lifetime of effect of this method ends on disconnection; if you want to initiate a new connection to a headband that has disconnected, you should call  <a class="el" href="classinteraxon_1_1bridge_1_1_muse.html#acdbab38fda3f2b2dd11b9c4adfe1ab52">run_asynchronously()</a>  on it again.</p>
<p>If this method is called multiple times within the lifetime of a single connection, any subsequent calls will do nothing other than print a log message.</p>
<p>Note that there is currently a race condition if  <a class="el" href="classinteraxon_1_1bridge_1_1_muse.html#acdbab38fda3f2b2dd11b9c4adfe1ab52">run_asynchronously()</a>  is called</p><ol type="1">
<li>as a result of a DISCONNECTED packet, and</li>
<li>on a different thread from the one that delivered the notification.</li>
</ol>
<p>This will be resolved in a future library release. For now, call  <a class="el" href="classinteraxon_1_1bridge_1_1_muse.html#acdbab38fda3f2b2dd11b9c4adfe1ab52">run_asynchronously()</a>  on the same thread that sent the DISCONNECTED packet, or after some modest delay (say 1 second.)</p>
<p><b>Threading:</b> This method is thread safe. </p>

</div>
</div>
<a id="a207c84a2673ca83025854eead6857937" name="a207c84a2673ca83025854eead6857937"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a207c84a2673ca83025854eead6857937">&#9670;&#160;</a></span>set_license_data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void interaxon::bridge::Muse::set_license_data </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint8_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allows forwarding of license data from cloud.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The encrypted license blob. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1936b8edbac90c239cd1b4412802875c" name="a1936b8edbac90c239cd1b4412802875c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1936b8edbac90c239cd1b4412802875c">&#9670;&#160;</a></span>set_notch_frequency()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void interaxon::bridge::Muse::set_notch_frequency </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceinteraxon_1_1bridge.html#a58395a61de0e5043388e9b077c1da576">NotchFrequency</a>&#160;</td>
          <td class="paramname"><em>new_frequency</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Changes notch frequency (power line frequency). <br  />
<br  />
 <b>Threading:</b> method is thread-safe. You can call it in the middle of execute operation, but in this case be aware that this operation will interrupt data streaming to set new notch frequency. Data streaming will be restored after that. If method is called before a connection is established, the right setting will be passed to device during connection routine. <br  />
</p>
<p>When combining a call setNotchFrequency with  <a class="el" href="classinteraxon_1_1bridge_1_1_muse.html#abba7b627c86e7ca0b2d4548f37410ba4">Muse::set_preset()</a>  setNotchFrequency can be called before or after the call to  <a class="el" href="classinteraxon_1_1bridge_1_1_muse.html#abba7b627c86e7ca0b2d4548f37410ba4">Muse::set_preset()</a>  The notch frequency will be applied to the preset after the preset is set.</p>
<dl class="section warning"><dt>Warning</dt><dd>This is only supported on Muse 2014 (  <a class="el" href="namespaceinteraxon_1_1bridge.html#a7d8651cfe049653aafbd7b392c966780a5cdccd438a6868468a0ade7172169f3a">MU_01</a>  ) headbands and then only with presets:<br  />
  <a class="el" href="namespaceinteraxon_1_1bridge.html#a1a322b306f3f093aa4e1a504e37ac6feaf603b0a437f0f3b9b7bf57c2668711ff">MusePreset::PRESET_10</a>  ,  <a class="el" href="namespaceinteraxon_1_1bridge.html#a1a322b306f3f093aa4e1a504e37ac6feac02dff2a16daec8c727f56d1dfb057a0">MusePreset::PRESET_12</a>  and  <a class="el" href="namespaceinteraxon_1_1bridge.html#a1a322b306f3f093aa4e1a504e37ac6fead34ca4c3173d0570e692cc67c54e3566">MusePreset::PRESET_14</a>  Under those presets, the only valid frequencies are:  <a class="el" href="namespaceinteraxon_1_1bridge.html#a58395a61de0e5043388e9b077c1da576a037b10f73b03449271dc0f064429f66c">NotchFrequency::NOTCH_50HZ</a>   <a class="el" href="namespaceinteraxon_1_1bridge.html#a58395a61de0e5043388e9b077c1da576a035bd874a2be438ba31e06a7536eb605">NotchFrequency::NOTCH_60HZ</a>  <br  />
</dd>
<dd>
Calling this with  <a class="el" href="namespaceinteraxon_1_1bridge.html#a58395a61de0e5043388e9b077c1da576a060ad31f9cb9fcec32f0f89e5470b596">NotchFrequency::NOTCH_NONE</a>  will do nothing.</dd>
<dd>
This does nothing on Muse 2016 (  <a class="el" href="namespaceinteraxon_1_1bridge.html#a7d8651cfe049653aafbd7b392c966780aa54d9cf7ce3423eab0cee654bbcb0874">MU_02</a>  ) or later headbands and on Muse 2014 (  <a class="el" href="namespaceinteraxon_1_1bridge.html#a7d8651cfe049653aafbd7b392c966780a5cdccd438a6868468a0ade7172169f3a">MU_01</a>  ) headbands with presets  <a class="el" href="namespaceinteraxon_1_1bridge.html#a1a322b306f3f093aa4e1a504e37ac6fea5b6c3926aa9c336102844efaddda4fa3">MusePreset::PRESET_AB</a>  or  <a class="el" href="namespaceinteraxon_1_1bridge.html#a1a322b306f3f093aa4e1a504e37ac6fea70e9327c1595cb3ad8390e51a8abe800">MusePreset::PRESET_AD</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_frequency</td><td>The new notch frequency.  </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7c14c72dc1587452924da325f9e6b083" name="a7c14c72dc1587452924da325f9e6b083"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c14c72dc1587452924da325f9e6b083">&#9670;&#160;</a></span>set_num_connect_tries()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void interaxon::bridge::Muse::set_num_connect_tries </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>num_tries</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>When LibMuse tries connect to a Muse, it will by default try only once before giving up. This is due to the fact that the user must allow the app permission to access the headband through a UI dialog. Setting this to a number larger than one will cause the UI dialog to pop up multiple times.  This function only works for model MU-02 Muses, calling it on a MU-01 will do nothing. This function was added for internal testing purposes, and we do not anticipate that 3rd party clients of the LibMuse library will need to modify this value. <br  />
</p>
<p><b>Threading:</b> This method is thread safe.  </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_tries</td><td>The number of times to try to connect before giving up.  </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abba7b627c86e7ca0b2d4548f37410ba4" name="abba7b627c86e7ca0b2d4548f37410ba4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abba7b627c86e7ca0b2d4548f37410ba4">&#9670;&#160;</a></span>set_preset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void interaxon::bridge::Muse::set_preset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceinteraxon_1_1bridge.html#a1a322b306f3f093aa4e1a504e37ac6fe">MusePreset</a>&#160;</td>
          <td class="paramname"><em>preset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Changes Muse Headband settings. <b> Threading: </b> method is thread-safe. You can call it in the middle of execute operation, but in this case be aware that this operation will interrupt data streaming to set new preset. Data streaming will be restored after that. If method is called before connection is established, the right setting will be passed to device during connection routine. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">preset</td><td>The new preset. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a903837955a3aa1fd0b3d27d52754080e" name="a903837955a3aa1fd0b3d27d52754080e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a903837955a3aa1fd0b3d27d52754080e">&#9670;&#160;</a></span>unregister_all_listeners()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void interaxon::bridge::Muse::unregister_all_listeners </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unregisters all registered connection listeners and data listeners.</p>
<p><b>Threading:</b> method is thread-safe. </p>

</div>
</div>
<a id="a46adba7aa089b8a4afd4299d61c10789" name="a46adba7aa089b8a4afd4299d61c10789"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46adba7aa089b8a4afd4299d61c10789">&#9670;&#160;</a></span>unregister_connection_listener()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void interaxon::bridge::Muse::unregister_connection_listener </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classinteraxon_1_1bridge_1_1_muse_connection_listener.html">MuseConnectionListener</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>listener</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unregisters connection listeners. <br  />
<br  />
 <b> Threading: </b> method is thread-safe. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">listener</td><td>The listener to unregister. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8514eba1643c357304bbd20ddbd54bcf" name="a8514eba1643c357304bbd20ddbd54bcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8514eba1643c357304bbd20ddbd54bcf">&#9670;&#160;</a></span>unregister_data_listener()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void interaxon::bridge::Muse::unregister_data_listener </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classinteraxon_1_1bridge_1_1_muse_data_listener.html">MuseDataListener</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>listener</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceinteraxon_1_1bridge.html#a7563f828d33f62e2b2f161b41a0d6846">MuseDataPacketType</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unregisters a data listener that was registered before.</p>
<p>If the listener was not registered before, then this method does nothing.</p>
<p><b>Threading:</b> method is thread-safe. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">listener</td><td>The listener to unregister. </td></tr>
    <tr><td class="paramname">type</td><td>The type of data packet the listener will stop receiving. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7d5fa838dbbb00161675d251c8254718" name="a7d5fa838dbbb00161675d251c8254718"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d5fa838dbbb00161675d251c8254718">&#9670;&#160;</a></span>unregister_error_listener()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void interaxon::bridge::Muse::unregister_error_listener </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classinteraxon_1_1bridge_1_1_muse_error_listener.html">MuseErrorListener</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>listener</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unregisters an info listener that was registered before.</p>
<p>If the listener was not registered before, then this method does nothing.</p>
<p><b>Threading:</b> method is thread-safe. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">listener</td><td>The listener to unregister. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="bridge__muse_8h_source.html">bridge_muse.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceinteraxon.html">interaxon</a></li><li class="navelem"><a class="el" href="namespaceinteraxon_1_1bridge.html">bridge</a></li><li class="navelem"><a class="el" href="classinteraxon_1_1bridge_1_1_muse.html">Muse</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
